# 알고리즘, 자료구조를 왜 배워야 하나?

특정한 경우에 특정 알고리즘을 딱 맞게 쓰는것과 몰라서 비효율적으로 푸는 것은 차이가 크다. -> 알고 모르는 것의 차이가 존재
# chatper 1
## linked list vs array

### array

- 연속 메모리 -> 한번에 할당되고 한 번에 해제된다
- Random Access 에 강하다
  - a[33] = 100 세팅한다고 하면, index 33 이라는 메모리 주소를 찾아야 한다
  - 100개의 공간을 확보 -> a는 그 공간의 시작주소이므로 100 + 33 X 8(type size)
  - +, x 한 번 만 하면 되므로 컴뷰터에서는 빠른 속도로 가능 -> 랜덤에 강하다
  - O(1) - 크기와 index 와 상관 없이 +, x 계산 한 번에 되므로 O(1)
- 삽입/삭제에 약하다(배열 끝 추가와 삭제는 괜찮다)
  - 중간에 삽입한다고 하면 - 앞의 것들 하나씩 복붙 + 삽입 + 뒤의 것들 하나씩 복붙
  - 따라서 삽입과 삭제는 배열의 요소 개수만큼 시간이 소요된다
  - O(N) - 배열의 개수만큼 시간이 소요된다


### Counting Sort
- O(N + K) 알고리즘
- k: 값의 범위
- 가장 빠른 알고리즘 - Count Sort !
- 단, 제한조건 있음
  - K값이 N2 으로 엄청 큰 경우에는 O(N + N2)=O(N2) -> 느림
  - 따라서 O(N) 최적일때 빠름
- 배열을 돌면서 인덱스의 값에 맞게 카운팅하고 카운팅에 따라 정리
- stream 으로 문자열이 주어진다면? -> 실시간으로 문자열이 쭉 들어온다는 말로, count sort 는 쓸 수 없다(count sort는 배열을 쭉 한바퀴 돌아야 하기 때문)

# Chapter 9
## Map
- key, value 로 저장하는 구조 
- Unordered Map: 순서가 없다 - hash map (go의 기본 map) 
- Ordered Map: 순서가 있다 - sorted map

## Hash Map
- hash 함수를 기준으로 저장
  - hash 함수: 잘게 부셔서 뭉친 것
  - 잘게 부셔서 뭉쳤기 때문에 다시 돌려놓을 수는 없다 -> One Way 함수(원래의 데이터를 알아낼 수 없다 - 입력값을 유추할 수 없다)
  - 데이터 검증: hash값이 같다면 입력한 데이터가 같을 확률이 높다 / hash값이 다르다면 입력한 데이터가 무조건 다르다 -> 데이터가 잘 왔는지 검증할 수 있다
  - 암호화: password를 HTTP(공개된 프로토콜이기 때문에 누구든 데이터를 까볼 수 있다) 통신으로 보내면 탈취가능성이 있다 -> password를 hash함수를 돌려 결과값을 서버로 보낸다
  - 가상화폐: hash key를 통해서 블록체인을 만들어 놓고 - 가능한 모든 값을 넣어서 알아내기(역hasing) - 시간 오래걸림 -> 신용
  - 손실압축: 1GB 입력 -> 4byte 출력, 복호화 불가능
- 순서가 없다(넣는 값에 상관없이 데이터가 나올 수 있음 - 정해진 규칙 없다)
- 속도가 빠름
- Spase(엉성한)한 자료구조 - 메모리가 앞부분 부터 차곡차곡 쌓이는 것이 아니라 빈틈이 많은 자료구조다

## 